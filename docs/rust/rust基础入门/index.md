---
title: rust 基础入门
---

### 3.1 变量与可变性

- 声明变量使用 let 关键字。
- 默认情况下，变量是不可变的(immutable)。
- 声明变量时，在变量前面加上 mut，就可以使变量可变。

**变量与常量**

- 常量(constant)，常量绑定以后也是不可变的，但是它与不可变的变量有很多区别：
  - 不可以使用 mut，常量永远都是不可变的
  - 声明常量使用 const 关键字，它的类型必须被标注
  - 常量可以在任何作用域内及进行声明，包括全局作用域
  - 常量只可以绑定到常量表达式，无法绑定到函数的调用结构或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命名规范：Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如
  - MAX_POINTS

**隐藏(shadowing)**

- 可以使用相同的名字声明新的变量，新的变量就会 shadow(隐藏)之前声明的相同变量
  - 在后续的代码中这个变量名就是心的变量

```rust
fn main(){
  let x = 5;
  let x = x + 1;
  println!("{}",x);// 6
}
```

- shadow 和把变量标记为 mut 是不一样的：
  - 如果不适用 let 关键之，那么重新给非 mut 的变量赋值会导致编译时错误
  - 而使用 let 声明的同名新变量，也是不可变的。
  - 使用 let 声明的同名新变量，它的类型可以与之前不同

```rust
fn main() {
    let spaces = "    ";
    let spaces = spaces.len();
    print!("{}", spaces);
}
```

### 3.2 数据类型

- 标量和复合类型
- Rust 是静态编译语言，在编译时必须直到所有变量的类型
  - 基于使用的值，编译器通常能够推断出它的具体类型
  - 但如果可能的类型比较多(例如把 String 转为整数的 parse 方法)，就必须添加类型的标注，否则编译会报错
  ```rust
  fn main() {
   // 不写 u32 类型就报错
   let guess: u32 = "42".parse().expect("Not a number");
  }
  ```

**标量类型**

- 一个变量类型代表一个单个的值
- Rust 有四个主要的标量类型
  - 整数类型
  - 浮点类型
  - 布尔类型
  - 字符类型

**整数类型**

- 整数类型没有小数部分
- 例如 u32 就是一个无符号的整数类型，占据 32 位的空间
- 无符号整数类型以 u 开头
- 有符号整数类型以 i 开头
- Rust 的整数类型 ：8 16 32 64 128 arch(size)
  - 每种都分 i 和 u，以及固定的位数
  - 有符号范围:
    - -(2^n-1)到 2^(n-1)-1
  - 无符号范围：
    - 0 到 2^n - 1

**isize 和 usize 类型**

- isize 和 usize 类型的位数由程序运行的计算机的架构所决定：
  - 如果是 64 位计算机，那就是 64 位的
  - (其余同理)....
- 使用 isize 或 usize 的主要场景是对某种集合进行索引操作。

**整数字面量**

- 除了 byte 类型外，所有的数值字面值都允许使用类型后缀。
  - 例如 57u8
- 如果你不太清楚应该使用哪种类型，可以使用 Rust 相应的默认类型
- 整数的默认类型就是 u32

**整数溢出**

- 例如： u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256，那么：
  - 调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic
  - 发布模式下(-release)编译：Rust 不会检查可能导致 panic 的整数溢出
    - 如果溢出发生：Rust 会执行“环绕”操作：
      - 256 变成 0 ，257 变成 1 ...
    - 但是程序不会 panic

**浮点类型**

- Rust 有两种基础的浮点类型，也就是含有小数部分的类型
  - f32，32 位，单精度
  - f64，64 位，双精度
- Rust 的浮点类型使用了 IEEE-754 标准来表述
- f64 时默认内心，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精度更高。

```rust
fn main() {
   let x = 2.0; // f64
   let y: f32 = 3.0; // f32
}

```

**数值操作**

加减乘除没啥好说的

**布尔类型**

和其它语言也一样，没啥好说的

**字符类型**

- Rust 语言中 char 类型被用来描述语言中最基础的单个字符。
- 字符类型的字面值使用单引号
- 占用 4 字节大小
- 是 Unicode 的标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等
  - U+0000 到 U+D7FF
  - U+E000 到 U+10FFFF
- 但 Unicode 中并没有“字符”的改良，所以直觉上认为的字符也许与 Rust 中的概念并不相符
