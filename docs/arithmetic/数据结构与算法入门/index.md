---
title: 数据结构与算法入门
sidebar_position: 1
---

C 语言进行学习 学习课程[数据结构与算法基础（青岛大学-王卓）](https://www.bilibili.com/video/BV1nJ411V7bd/?spm_id_from=333.337.search-card.all.click&vd_source=425088ab9830d3bc1e0cb3f50b07aad5)

学习原因：算法依托答辩(悲)

## 第一章 绪论

### 1.1 数据结构的研究内容(略)

### 1.2 基本概念和术语

#### 1.2.1 数据、数据元素、数据项和数据对象

- 数据(Data)
- 数据元素(Data Element)
- 数据项(Data Item)
- 数据对象(Data Object)

- 数据、数据元素、数据项三者的关系
  数据 > 数据元素 > 数据项

#### 1.2.2 数据结构

- 数据结构包括以下三个方面的内容

1. 数据元素之间的逻辑关系，也称为`逻辑结构`
2. 数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的`物理结构`或数据的`存储结构`
3. 数据的`运算和实现`，即对数据元素可以施加的操作以及这些操作在对应的存储结构上的实现

数据结构的两个层次

1. 逻辑结构

- 描述数据元素之间的逻辑关系
- 与数据的存储无关，独立于计算机
- 是从具体问题抽象出来的数学模型

2. 物理结构(存储结构)

- 数据元素及其关系在计算机存储器中的结构(存储方式)
- 是数据结构在计算机中的表示

**逻辑结构与存储结构的关系**

- 存储结构是逻辑关系的映像与元素本身的映像
- 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
- 两者综合起来建立了数据元素之间的结构关系

**逻辑结构的种类**

划分方法一

(1) 线性结构

有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。

例如：线性表、栈、队列、串

(2) 非线性结构

一个结点可能有多个直接前趋和直接后继

例如：树、图

**划分方式二————四类基本逻辑结构**

(1) 集合结构: 结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

(2) 线性结构:结构中的数据元素之间存在着一对一的线性关系。

(3) 树形结构:结构中的数据元素之间存在着一对多的层次关系。

(4) 图状结构或网状结构:结构中的数据元素之间存在着多对多的任意关系。

**存储结构的种类**

**四种基本的存储结构:**

- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

#### 1.2.3 数据类型和抽象数据类型

- 在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。
  - 例如，C 语言中:
    - 提供 int,char, float, double 等基本数据类型
    - 数组、结构、共用体、枚举等构造数据类型
    - 还有指针、空(void)类型
    - 用户也可用 typedef 自己定义数据类型
- 高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。

  - 例如，C 语言中定义变量 i 为 int 美型，就表示 i 是[-min,max]范围的整数，在这个整数集上可以进行+、-、\ 、\*、\、% 等操作

- 数据类型的作用
  - 约束变量或常量的取值范围。
  - 约束变量或常量的操作。
- 抽象数据类型
  是指一个数学模型以及定义在此数学模型上的一组操
  - 由用户定义,从问题抽象出数据模型（逻辑结构)
  - 还包括定义在数据模型上的一组抽象运算(相关操作)
  - 不考虑计算机内的具体存储结构与运算的具体实现算法
    一个抽象数据类型的`定义格式`如下：

```cpp
ADT 抽象数据类型名 {
  数据对象:<数据对象的定义>
  数据关系:<数据关系的定义>
  基本操作:<基本操作的定义>
} ADT 抽象数据类型名
```

其中：

- 数据对象、数据关系的定义用伪代码描述
- 基本操作的定义格式为：
  - 基本操作名（参数表）
  - 初始条件：（初始条件描述）
  - 操作结果：（操作结果描述）

**基本操作**定义格式说明：

参数表：

- 赋值参数 只为操作提供输入值。
- 引用参数以&打头，除可提供输入值外，还将返回操作结果

初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，
则操作失败，并返回相应出错信息，若初始条件为空，则省略之。

操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果

抽象数据类型（ADT）定义举例：Circle 的定义

```c
ADT 抽象数据类型名 {
  Data
    数据对象的定义
    数据元素之间逻辑关系的定义
  Operation
    操作 1
      初始条件
      操作结果描述
    操作 2
      .....
    操作 n
      .....
}
```

```c
ADT Circle {
  数据对象：D={r,x,y|r,x,y均为实数}
  数据关系：R={<r,x,y>|r是半径,<x,y>是圆心坐标}
  基本操作：
    Circle(&C,r,x,y)
      操作结果：构造一个圆
    double Area(C)
      初始条件：圆已存在
      操作结果：计算面积
    double Circumference(C)
      初始条件：圆已存在
      操作结果：计算周长
  .....
}ADT  Circle
```

**抽象数据类型(ADT)定义举例：复数的定义**

```c
ADT Complex {
  D = {r1,r2|r1,r2都是实数}
  S = {<r1,r2>|r1是实部,r2是虚部}
  assign(&C,v1,v2)
    初始条件：空的复数C已存在
    操作结果：构造复数C，r1,r2分别被赋以参数v1,v2的值
  destory(&C)
    初始条件：复数C已存在
    操作结果：复数C被销毁
}ADT Complex
```

### 1.3 抽象数据类型的表示与实现

![img](./img/1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%B0%8F%E8%8A%82.png)

#### 1.3.1 抽象数据类型如何实现

- 抽象数据类型可以通过固有的数据类型(如整形、实型、字符型等)来表示和实现
  - 即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作

**`注`：在本门课程的学习过程中，我们使用`类C语言`（介于伪代码和 C 语言之间）作为描述工具。**

#### 1.3.2 用 C 语言真正实现抽象数据类型的定义

- 例如：抽象数据类型"复数"的实现

```c
typedef struct {
  float realpart; /**实部 */
  float imagpart; /**虚部 */
}Complex;          /**定义复数抽象类型 */
```

```c
void assign (Complex * A,float real, float imag) {
  A->realpart = real;/**实部赋值 */
  A->imagpart = imag;/**虚部赋值 */
}
void add(Complex * C, Complex * A, Complex * B) {
  c->realpart = A.realpart + B.realpart;
  c->imagpart = A.imagpart + B.imagpart;
}
```

### 1.4 算法与算法分析

![img](./img/%E7%A0%94%E7%A9%B6%E5%86%85%E5%AE%B9.png)

#### 1.4.1 算法的定义

- 对特定问题**求解方法和步骤**的一种描述，它是`指令`的有限`序列`。其中每个指令表示一个或多个操作。

#### 1.4.2 算法的描述

- 自然语言：英文、中文
- 流程图：传统流程图、NS 流程图
- 伪代码：类语言：类 C 语言
- 程序代码：C 语言程序、JAVA 语言程序、js.....

#### 1.4.3 算法与程序

- **算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法。
- **程序**是用某种程序设计语言对算法的具体实现

**程序 = 数据结构 + 算法**

- 数据结构通过算法实现操作。
- 算法根据数据结构设计程序

#### 1.4.4 算法特性

**一个算法必须具备以下五个重要特性：**

- **有穷性** 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
- **确定性** 算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。
- **可行性** 算法是可以执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。
- **输入** 一个算法有零个或多个输入
- **输出** 一个算法有一个或多个输出

#### 1.4.5 算法设计的要求

- 正确性(Correctness)

  - 算法满足问题要求，能正确解决问题。算法转换为程序要注意：
    1. 程序中**不含语法错误**
    2. 程序对于**几组输入数据**能够得出满足要求的结果
    3. 程序对于**精心选择的、典型、苛刻且带有刁难性**的几组输入程序能够得出满足要求的结果
    4. 程序对于**一切合法的输入数据**都能得出满足要求的结果

  通常以**第三层**意义上的正确性作为衡量一个算法是否合格的标准

- 可读性(Readability)
  - 算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解
  - 另一方面，晦涩难读的算法易于隐藏较多错误而难以调试
- 健壮性(Robustness)
  - 指当**输入非法数据**时，算法恰当的做出反应或静心相应处理，而不是产生莫名其妙的输出结果
  - 处理出错的方法，不应时中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理
- 高效性(Efficiency)
  - 要求花费尽量少的时间和尽量低的存储需要(时间为主，空间为辅)

#### 1.4.6 算法分析

算法分析的目的是看算法实际是否可行，并在同一问题存在多的算法时可进行性能上的比较，以便从中挑选出比优的算法

- 一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑**算法的效率**，通过算法的效率高低来评判不同算法的优劣程度。
- 算法效率以下两个方面来考虑：

  1. 时间效率：指的是算法所消耗的**时间**；
  2. 空间效率：指的是算法执行过程中所耗费的**存储空间**

  - 时间效率和空间效率有时候是矛盾的

- 算法时间效率的度量
  - 算法时间效率可以用依据该算法编制的程序在计算机上执行**所消耗的时间**来度量
  - 两种度量方法
    - 事后统计
      - 将算法实现，测算其时间和空间开销。
      - 缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣
    - 事前分析
      - 对算法所消耗资源的一种估算方法。

**事前分析方法**

- 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的**时间**与算法中进行的操作**次数**乘积

  算法运行时间=一个简单操作所需的时间 × 简单操作次数

- 也即算法中每条语句的执行时间之和

算法运行时间 = Σ 每条语句的执行次数 × 该语句执行一次所需的时间

算法运行时间 = Σ 每条语句频度 × 该语句执行一次所需的时间

每条语句执行一次所需的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量。是由机器本身软硬件环境所决定的，它与算法无关。

所以，我们可以**假设执行每条语句所需的时间均为`单位时间`**。此时对算法的运行时间和讨论就可转化为讨论该算法中所有语句的执行次数，即频度之和了。

- 例如：两个 n×n 矩阵相乘的算法可描述为：

```c
for (int i = 1; i <= n; i++) { // n + 1 次
    for (int j = 1; j <= n; j++) { // 执行 n(n+1) 次
        c[i][j] = 0;// 执行 n * n 次
        for (int k = 0; k < n; k++) { // 执行 n*n(n+1)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];// n*n*n 次
        }
    }
}
```

- 为了便于比较不同算法的时间效率，我们仅比较它们的数量级

```c
例如：两个不同的算法，时间消耗分别是：
  T1(n) = 10n^2 与 T2(n) = 5n^3
T1好
```

- 若有某个辅助函数 f(n)，是的当 n 趋近于无穷大时，T(n)/f(n)的极限值为**不等于零的阐述**，则称 f(n)是 T(n)的同数量级函数。记作 T(n)=O(f(n)),称 O(f(n))为**算法的渐进时间复杂度**(O 是数量级的符号)，简称**时间复杂度**

对于求解矩阵相乘问题，算法耗费时间：T(n)=2n^2+3n^2+2n+1

n->∞ 时，T(n)/n^3 -> 2,这表示 n 充分大时，T(n)与 n^3 是同阶或同级数量级，引入大"O"记号，则 T(n)可记作：

T(n)=O(n^3) 这就是求解矩阵相乘问题的**算法渐进时间复杂度**

一般情况下，不必计算所有操作的执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模 n 的某个函数，用 T(n)表示

算法中基本语句重复执行的次数是问题规模 n 的某个函数 f(n)，算法的时间量度记作：T(n) = O(f(n))

它表示随着 n 的增大，算法执行的时间的增长率和 f(n)的增长率相同，称`渐进时间复杂度`

n 越大算法的执行时间越长

- 排序：n 为记录数
- 矩阵：n 为矩阵的结束
- 多项式：n 为多项式的项目
- 集合：n 为元素个数
- 树：n 为数的节点个数
- 图：n 为图的顶点或边数

#### 1.4.7 分析时间复杂度的基本方法

- 定理 1.1 忽略所有**低次幂和最高次幂系数，体现出增长率的含义**
  - 找出`语句频度最大`的`那条语句`
  - 计算`基本语句`的频度得到问题规模 n 的某个函数 f(n)
  - 取其数量级用符号“O”表示
- 时间复杂度是由嵌套最深层语句的频度所决定的
